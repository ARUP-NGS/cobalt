#!/usr/bin/env python3
# -*- coding: utf-8 -*-


import argparse
import logging
from cobaltcnv import training

logging.basicConfig(level=logging.INFO,
                    format='%(asctime)s --> %(message)s',
                    datefmt='%Y-%m-%d %H:%M:%S')

if __name__=="__main__":
    parser = argparse.ArgumentParser("Cobalt CNV caller")

    subparsers = parser.add_subparsers(help='sub-command help', dest='subparser_name', title='sub-commands')

    train = subparsers.add_parser('train', help="Create a new CNV calling model from a depth file")

    train.add_argument("--depths", "-d", help="BED-formatted file with raw sample depths")
    train.add_argument("--save-model", "-o", help="Path to which trained model should be saved")
    train.add_argument("--num-components", help="Number of components to subtract during training", type=int,
                        default=6)
    train.add_argument("--no-mask", help="Turn off site masking", action='store_true', default=False)
    train.add_argument("--chunk-size", help="Number of sites to include in a chunk", type=int, default=1000)
    train.add_argument("--max-cv", help="Maximum depth CV for sample inclusion", type=float, default=1.0)

    predict = subparsers.add_parser('predict', help="Identify CNVs in a sample using a model")
    predict.add_argument("--model", "-m", help="Model file to use for prediction")
    predict.add_argument("--min-qual", "-q", help="Minimum quality to emit CNV call", type=float, default=0.80)
    predict.add_argument("-o", "--output", help="Output path for prediction results", default=None)
    predict.add_argument("-a", "--alpha", help="Transition parameter for HMM", default=0.05, type=float)
    predict.add_argument("-b", "--beta", help="Other transition parameter for HMM", default=0.05, type=float)
    predict.add_argument("--sex", help="Force assume sample sex, (=M, =F)", choices=['M', 'F'])


    plot = subparsers.add_parser('plot', help="Plot emission distributions and transformed depths for a range of sites")
    plot.add_argument("--model", "-m", help="Model file")
    plot.add_argument("--site", help="Which site to emit information for (either site index or region string)")

    # parser.add_argument("--no-rm-outliers", help="Do not remove outlier data points during training", action='store_true', default=False)

    # parser.add_argument("--threshold", help="Max Kullback-Leibler distance between dists for emitted targets", type=float, default=10.0)
    # parser.add_argument("--kl", help="Max Kullback-Leibler dist for site optimization, set this to 0.0 to disable site optimization", type=float, default=0.0)

    args = parser.parse_args()

    if args.subparser_name == "train":
        print("Training!")
        training.train(args.depths, args.save_model, use_depth_mask=not args.no_mask, num_components=args.num_components, max_cv=args.max_cv, chunk_size=args.chunk_size)

    elif args.subparser_name == "predict":
        print("Predicting!")

    elif args.subparser_name == "plot":
        print("Plotting!")

        # assume_female = None
        # if args.sex is not None:
        #     assume_female = args.sex == 'F'
        # predictpca.predict(args.model, args.depths,
        #                    output_path=args.output,
        #                    truncate_depths=True,
        #                    min_quality=args.min_qual,
        #                    alpha=args.alpha,
        #                    beta=args.beta,
        #                    regionstr=args.site,
        #                    assume_female=assume_female)


    # elif args.command[0] == PLOT:
    #     viz.plot_single_site(args.model, args.site, depths_path=args.depths)
    #
    #
    # elif args.command[0] == DESCRIBE:
    #     predictpca.emit_site_info(args.model, threshold=args.threshold, emit_masked_sites=True, output=args.output)

    else:
        logging.error("Unrecognized subcommand: {}".format(args.subparser_name))


